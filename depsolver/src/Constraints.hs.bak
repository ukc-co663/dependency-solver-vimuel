{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE Strict #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE KindSignatures #-}

module Constraints where

-- import qualified Data.ByteString as B
import Data.Text (Text)
import qualified Data.Text as Text
import Data.Foldable
import Data.Set (Set)
import qualified Data.Set as Set
import Data.String (IsString)
import Data.Monoid
import Data.List (nub)

{-| [+A,-B,+C] would be Conj [Installed "A", Not (Installed "B"), Installed "C"] -}
data Constraint a
  = F                                 -- ^ trivially false constraint
  | T                                 -- ^ trivially true constraint
  | Installed a                            -- ^ assert that installed (A > 0)
  | Depends a a                       -- ^ left depends on right to be installed first (A < B)
  | DependsInit a a                   --
  | Conflicts a a                     -- ^ left requires right to be uninstalled first (-A > B)
  | If (Constraint a) (Constraint a)  -- ^ left implies right ((A > 0) => (A < B))
  | Conj [Constraint a]               -- ^ conjunction of constraints, NB: simplify empty to F
  | Disj [Constraint a]               -- ^ disjunction of constraints, NB: simplify empty to F
  | Not (Constraint a)                -- ^ invert a constraint (not (A > 0))
  deriving (Eq, Foldable, Functor, Show)

{-|
>>> simplify $ Conj [Installed "A"]
Installed "A"

>>> simplify $ Not (Conj [])
Not Empty

Probably buggy, didn't test much :/
-}
simplify :: Eq a => Constraint a -> Constraint a
simplify c =
  case c of
    Conj cs ->
      let cs' = filter (/= T) $ map simplify cs
      in if F `elem` cs'
        then F
        else case cs' of
          [] -> T
          [c] -> c
          cs -> Conj cs
    Disj cs ->
      let cs' = filter (/= F) $ map simplify cs
      in if T `elem` cs'
        then T
        else case cs' of
          [] -> T
          [c] -> c
          cs -> Disj cs
    Not c ->
      case simplify c of
        Not c -> c
        c -> Not c
    If c1 c2 ->
      case (simplify c1, simplify c2) of
        (F,_) -> T
        (T,c) -> c
        (_,T) -> T
        (c1,c2) -> If c1 c2
    x -> x

usedIn :: Eq a => Constraint a -> [a]
usedIn = nub . foldl' (flip (:)) []

-- usedIn :: Ord a => Constraint a -> Set a
-- usedIn = foldl' (flip Set.insert) Set.empty

fold :: (b -> a -> b) -> b -> Constraint a -> b
fold = foldl'
