{-# LANGUAGE OverloadedStrings #-}
module DFS where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

import Parser

for = flip . map

install :: Map Name [Pkg] -> Pkg -> Set Pkg -> [Pkg]
install repo target installed next =
    if next `elem` installed then undefined
      else
        for dss \ds ->
          for ds \d ->
            if d `elem` installed

            dss = map (concatMap (get repo)) (depends next)
            -- installSeqss = map (go repo target outp)
{-
for each permutation of dependencies
  for each dependency
    if dependency not already installed
      try install
      catch not-installable
        break
  return solution
throw not-installable
-}

get :: Map Name [Pkg] -> PkgConstr -> [Pkg]
get repo (PkgConstr name versionConstr) =
  case Map.lookup name repo of
    Nothing -> []
    Just pkgs -> throwOut $ pkgs
  where
    throwOut = case versionConstr of
        Nothing -> id
        Just (r,v) -> filter $ \p -> toOperator r (version p) v

exTarget :: Set Pkg
exTarget = Set.fromList
            [("_VIRTUAL_=",True),("B=3.2",False),("A=2.1",True),("D=10.3.1",True),("C=1",True),("B=3.0",False)]

exRepo :: Map Name [Pkg]
exRepo = fromList [("A",[Pkg {pkgId = ("A",[2,1]), size = 1672, depends = [[PkgConstr "B" (Just (GtEq,[3,1]))
,PkgConstr "C" (Just (Eq,[1]))],[PkgConstr "D" Nothing]], conflicts = []}]),("B",[Pkg {pkgId = ("B",[3,2]), size = 211234, depends = [], conflicts = [PkgConstr "B" (Just (Lt,[3,2]))]},Pkg {pkgId = ("B",[3,0]), size = 83619, depends = [], conflicts = []}]),("C",[Pkg {pkgId = ("C",[1]), size = 23, depends = [], conflicts = [PkgConstr "B" Nothing]}]),("D",[Pkg {pkgId = ("D",[10,3,1]), size = 88847, depends = [], conflicts = [PkgConstr "B" (Just (GtEq,[3,1]))]}])]

exTarget :: Pkg
exTarget = Pkg {pkgId = ("_VIRTUAL_",[]), size = 0, depends = [[PkgConstr "A" Nothing]], conflicts = []}
