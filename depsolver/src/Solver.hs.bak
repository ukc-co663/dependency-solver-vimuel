{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ImplicitParams #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE FlexibleInstances #-}
-- {-# LANGUAGE Strict #-}
module Solver where

import Data.Monoid
import Data.Traversable (for)
import Data.Ord (comparing)
import qualified Data.Foldable as Foldable (foldl', length)
import Data.List (sortBy, reverse)
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (catMaybes, mapMaybe, isNothing, fromJust)
import Data.Map.Lazy (Map, (!))
import qualified Data.Map.Lazy as Map
import Control.Monad (unless, forM, forM_, when)
import Data.IORef
import System.FilePath ((</>))
import System.Process
import Data.List (sortBy, subsequences)
import Data.Ord (comparing)
import System.IO
import qualified Data.Text as Text
import qualified Data.Text.IO as Text
import Data.Text.Read (decimal, signed)
import Data.Ord (Down(..))
import Data.Time.Clock (getCurrentTime, diffUTCTime)

import Constraints
import Parser

get :: Map Name [Pkg] -> PkgConstr -> [Pkg]
get repo (PkgConstr name versionConstr) =
  case Map.lookup name repo of
    Nothing -> []
    Just pkgs -> throwOut $ pkgs
  where
    throwOut = case versionConstr of
        Nothing -> id
        Just (r,v) -> filter $ \p -> toOperator r (version p) v

mkDepConfConstrs repo pkg = If (Installed pkg) (Conj [deps,confs])
  where
    deps = Conj . map (Disj . map (Disj . (F :) . map (Depends pkg) . get repo)) . depends $ pkg
    confs = Conj . map (Conj . (T :) . map (Conflicts pkg) . get repo) . conflicts $ pkg

-- incredibly wasteful way to calculate this, but my time is more precious than CPU cycles
process :: Map Name [Pkg] -> [Pkg] -> Set Pkg -> [Constraint Pkg] -> [Constraint Pkg]
process repo toProcess alreadyProcessed constrs =
  case toProcess of
    [] -> constrs
    (p:toProcess) ->
      if Set.member p alreadyProcessed
        then process repo toProcess alreadyProcessed constrs
        else
          let c = mkDepConfConstrs repo p
          in process repo (depsConfls repo p ++ toProcess) (Set.insert p alreadyProcessed) (c:constrs)

depsConfls :: Map Name [Pkg] -> Pkg -> [Pkg]
depsConfls repo pkg = concatMap (get repo) $ concat (depends pkg) ++ conflicts pkg

go path = do
    (Just hZ3In, Just hZ3Out, _, z3) <- -- Just hZ3Out, Just hZ3Err, z3) <-
      createProcess (proc "z3" ["-smt2","-in"])
      -- createProcess (shell "time z3 -smt2 -in")
        { std_in  = CreatePipe
        , std_out = CreatePipe
        , std_err = Inherit }

    (repo, initial, target) <- parseInput path

    let initialPkgs = map (\(name,vers) -> head . filter (\p -> version p == vers) $ repo ! name) initial
        initial' = map (mkDepConfConstrs repo) initialPkgs
        constrs = process repo (usedIn target) (Set.fromList (concatMap usedIn initial')) []
    res <- callSMT True hZ3In hZ3Out (Set.fromList initialPkgs) (target:initial'++constrs)
    return res


    -- writeFile (path </> "commands.json") (show res)
    -- callProcess "python" $ ["tests/judge.py"]
    --                   ++ map (path </>)
    --                       [ "repository.json"
    --                       , "initial.json"
    --                       , "commands.json"
    --                       , "constraints.json" ]


callSMT :: Bool -> Handle -> Handle -> Set Pkg -> [Constraint Pkg] -> IO [(Text.Text, Bool)]
callSMT logging hIn hOut initial constrs = do

    putStrLn "Calculating constraints and submitting to Z3..."
    t1 <- getCurrentTime
    counter <- newIORef (1 :: Int)

    let toZ3 constraint = do
          let constr = toSmtLib constraint
          when logging $ do
            i <- readIORef counter
            Text.appendFile "log-in.txt" $ constr <> " ; " <> Text.pack (show i) <> "\n"
            modifyIORef' counter succ
          Text.hPutStrLn hIn constr

        variables :: [Pkg] = usedIn . Conj $ constrs
        costs = map (\p -> if Set.member p initial then (p,0,1000000) else (p,size p,0)) variables

    mapM_ (toZ3 . DeclareVar) $ variables
    toZ3 $ Objective costs
    mapM_ (toZ3 . Assert) constrs
    toZ3 Submit
    t2 <- getCurrentTime
    putStr "Constraints submitted to Z3 in "
    putStrLn . show $ diffUTCTime t2 t1

    t1 <- getCurrentTime
    model <- Text.hGetContents hOut
    t2 <- getCurrentTime
    putStrLn $ "Z3 finished in " <> (show $ diffUTCTime t2 t1)
    when logging $ Text.appendFile "log-out.txt" model
    return $ parse [] (Text.lines model)
  where
    parse acc [] = acc
    parse acc (x:xs) = case Text.stripPrefix "(define-fun " . Text.stripStart $ x of
      Nothing -> parse acc xs
      Just rest ->
        let b = Text.isInfixOf "true" . head $ xs
            pkgId = Text.takeWhile (/= ' ') . Text.filter (/= '|') $ rest
        in parse ((pkgId,b):acc) (tail xs)
